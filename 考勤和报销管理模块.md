# 考勤和报销管理模块

### 考勤管理-登陆-实现登陆操作
1. 把login.html改为login.jsp, login.jsp不用放进文件夹中, 它属于基本页面
2. 填好登陆表单的内容, 并封装成表单, 给出一个显示错误信息的地方
3. 在EmployeeServlet中创建login方法
4. 在service层有两个思路进行登陆验证
> 1. dao.find(empId, password)<br/>
"select * from employee where empid=? and password=?"
>2. 分两步实现, 先判断用户名是否正确; 用户名不正确, 登陆失败, 用户名正确, 再判断密码
5. 再servlet中要把service层返回的emp保存到session域中

### 考勤管理-登陆和注销-登陆成功后显示不同导航菜单
1. 先把top.html改为top.jsp, 在top.jsp中在myInfo的标签中动态显示session中的emp.realname
2. 把left.html改为left.jsp, 并修改其中的内容, 左边的菜单栏显示的菜单要根据登陆者的身份获取, 普通员工不能看到管理人员特有的功能
- 目前是普通员工只能看到考勤和报销, 管理人员才能看到部门员工等信息, 个人平台都能看到
- 注意:如果css样式出错了, 把<'dl'>标签放到if标签的外面
3. 修改top.jsp中的退出功能, 跳转到Servlet中的logout方法, 在logout方法中不用跳转到业务层, 直接重定向到login.jsp, 同时要结束当前的session
`request.getSession().invalidate();`

### 考勤管理-登陆-实现验证码
1. 引入老师提供RandomServlet, 并在web.xml中注册
- RandomServlet中使用swing随机生成了一张验证码图片, 并且把验证码的字符串保存到session中, 名为"randStr"
2. 在login.jsp中,在验证码图片的cite标签中插入<image>标签, 老师玩了个小花样, 把image标签中的src的值改为random.jsp, 其实是在web.xml中为RandomServlet注册了一个叫/random.jsp的路径
3. 给验证码图片加上点击事件, 在绑定函数中获取图片并修改它的地址属性  
`$("#randImg").attr("src", "random.jpg")`  
但是像上面这样写, 就算点击了图片, 由于浏览器缓存的原因并不会再次去访问RandomServelt  
`$("#randImg").attr("src", "random.jpg?time="+new Date().toLocaleString());`  
我们给他带上一个不会重复的参数, 这样就不会缓存了
4. 在servlet的login方法中, 获取用户输入的verfyCode, 和在session中的randStr比较, 如果验证码为空或者不正确, 转发回login.jsp显示错误信息(加上return)  

### 考勤管理-签到-前台代码实现
> 重点练习ajax
1. 创建考勤类Duty, Duty类中除了有数据库中的五个字段, 还要持有一个员工属性, empid和emp同时存在
2. 搭建好MVC三层框架
3. 改动left.jsp, 签到签退访问dutyAdd.jsp, 给管理人员也加上签到签退的功能
4. 在dutyAdd.jsp中导入jquery.js文件, 给登陆的按键绑定一个单击事件. 当点击时, 发送给服务器一个ajax请求, 下面是jQuery中ajax的写法

```
        $(function () {
            //给签到按钮绑定一个单击事件
            $("#signin").click(function () {
                //发送一个ajax请求, 完成签到, 并通过回调函数显示签到结果
                $.ajax({
                    url:"/OASystem/DutyServlet?method=signin",
                    type:"POST",
                    dataType:"text",
                    success:function (data) {
                        
                    }
                })
            })
        });
```
5. DutyServlet中要给出signin方法, 在方法中先在session中获得当前登陆对象,然后获得对象的empid, 并调用service层的signin方法传入参数empid完成签到, 返回值是int类型, 1表示成功, 0失败, 2已经签到  

### 考勤管理-签到-全部功能实现
1. 完成service业务层, 过程如下
- 判断用户是否已经签到, 调用dao中的find方法, 传入empid和今天的日期(先创建今天的util.Date, 再转化为sql.Date传进去)
- 如果已经签到返回2, 如果没有签到就进行签到

```
    public int signin(String empid) {
        //判断用户是否已经签到, 需要两个参数empid和today(今天的日期, 每天能签一次到)
        Date date = new Date();//拿到现在的时间
        java.sql.Date today = new java.sql.Date(date.getTime());//利用getTime()的共性创建用于数据库的Date
        boolean flag = dutyDao.find(empid, today);//查看今天是否已经签到

        //根据用户是否签到进行操作
        if(flag){
            return 2;
        }else{
            //没有签到,完成签到
            Duty duty = new Duty();
            duty.setEmpid(empid);//员工id
            duty.setDtDate(today);//今天的日期
            //设置签到的时分秒
            DateFormat df = new SimpleDateFormat("hh:mm:ss");
            String signintime = df.format(today);
            duty.setSigninTime(signintime);

            //调用dao层进行签到
            return dutyDao.save(duty);//成功会返回1,失败返回0
        }
    }
```
- 在dao层的find方法中, 给出默认属性flag为false,也就是默认是没有找到签到信息
- 写sql语句的时候,要注意主键自增的问题, 上网查看mysql如何实现主键自增  
**`ALTER TABLE duty MODIFY dtid INT AUTO_INCREMENT;`**  

```
在设置了主键自增后,如果想利用主键自增去给某个字段自动赋值, 那么我们在写sql语句的时候可以省略该字段的参数,  
但是要注明是给表中的哪些字段赋值参数
    String sql = "insert into duty(emprid, dtdate, signintime, signouttime) values(?,?,?,?)";
    Object[] params = {duty.getEmpid(), duty.getDtDate(), duty.getSigninTime(), null};
    return qr.update(sql, params);
上面duty(给出要赋值的参数), 开始的时候因为没有在表名后面用括号指定参数, 搞得一直报参数不对应的错误  
  
想要清空表中的所有数据包括让主键归零开始自增代码如下,如果权限不足上网找办法  
TRUNCATE TABLE duty

```
### 考勤管理-签退-全部功能实现
1. 在dutyAdd.jsp中给签退按钮绑定事件, 使用ajax, 只用给出url和success即可
2. 由于打算在servlet中直接把签退结果的字符串返回给jsp, 所以在servlet中使用response.getWriter()响应ajax请求的之前, 还需要设置返回的内容为文本格式,编码utf-8
3. service层中可以沿用signin中的代码判断是否签到了,后面的代码也能沿用, 但是调用dao层的时候变成调用update方法(更新签退时间)
4. **==注意的问题==**

```
使用ajax时, 如果servlet响应字符串回去, 需要设置字符串的格式和字符集, 像下面的代码如果想要抽取response.getWriter方便复用的话,  
还要把设置格式的代码放在前面
    response.setContentType("text/html;charset=utf-8");//设置响应内容的格式和字符集
    PrintWriter out = response.getWriter();
    out.println(....)
```
- 显示时间的格式 HH:mm:ss是24小时格式, hh:mm:ss是12小时格式  


### 考勤管理-通过Ajax获取查询条件之部门列表
> 回顾:之前员工管理页面的思路是不直接到jsp显示, 而是先到servlet中获取数据后再到jsp页面显示  

> 但部门列表换一种思路, 先到jsp页面, 让后用ajax局部刷新获得数据  

1. 创建dutyList.jsp, 把html中的内容复制过来
2. 修改left.jsp, 考勤管理只有管理人员才能看见
3. ajax, 加载页面完成后, 获取所有的部门列表并输出, 给出url和success参数即可, 返回的数据是json格式的数据
4. 在servlet中创建findAllDept方法, 重用Deptservlet中查找所有部门的方法, 但是不使用转发/重定向, 使用ajax
5. 创建gson对象, 直接调用toJson方法把deptList变成字符串, 写完servlet的代码不要直接写json的回调函数, 先在浏览器地址栏访问一下servlet, 看能不能得到json数据, 注意(如果用gson拼接json字符串的时候, 可以去除对象中的某些属性)
6. 回调函数 
- 在回调函数中, 先把json字符串转化为js对象, 使用eval函数  
`eval("var arr = " + jsonStr);`
- for循环拼接所有的option字符串
- 一次性写到servlet deptno列表中

### 考勤管理-使用Ajax查询考勤信息
1. 在dutyList.jsp中给查询按键绑定点击事件, 事件中分两步:
- 获得三个查询条件的值, 使用alert()初步调试
- 通过Ajax获得请求得到数据, 并通过回调函数输出数据. 这里的ajax请求需要参数url, type, data(以json格式给出), datatype,success
2. 在servlet中1)获得三个查询条件, 2)调用业务层完成查询操作, 3)返回json字符串
3. 完成service和dao层的查询代码, dao中涉及多表查询
4.  写完dao层先别急着写回调函数, 先用浏览器访问servlet, 发现签到日期显示的格式有问题, 我觉得在dao层可以处理, 但是老师演示了在gson中将日期格式化(百度gson, 日期格式化)
5.  编写回调函数:1)把json数据转换为js对象, 2)拼接考勤信息列表字符串, 3)一次性写入到指定位置
> 遇到问题 : 使用Ajax查询考勤信息出错, Servlet没有问题, 就是jsp中, 点完查询按钮没用,  
解决 : 没有把ajax请求代码写在绑定的按键代码中
6. 现在的问题是默认只能找到总裁办的人, 设置一条value为0的option标签, 放在ajax拼接option串的开始位置, 注意在日期条件的时候要设置比较(也可以不比较, 只查找相等的)

### 使用POI导出考勤数据到xls
1. 导出数据到表格一般有两个插件POI和JXL
2. 导入jar包, 根据模板进行学习, 结合自己的需求复制粘贴修改
3. 给导出按键绑定单击事件  
- 获取三个查询条件的值
- 访问指定的servlet, 不使用ajax, (因为Ajax是通过回调函数处理结果的, 导出XLS是直接返回流, 所以也不使用转发和重定向)
- 在servlet中创建exportXLS方法, 复制findDuty方法, 只改变最后的步骤
4. 复制POI的模板, 修改为Duty的
> 在保存xls文件的时候, 不能按照模板的保存, 那样会保存到本地(服务器上). 获取response中的outputstream用于往服务器写数据, 
5. 进入服务器的文件夹, 在conf文件中找到web.xml, 找到xls文件的格式, 并设置响应头
> 具体参数DutyServlet中的exportXLS方法

### 报销管理-理解数据库表和创建实体类
1. 先解决报销单表和报销单明细表, 创建两个实体类Expense和ExpenseItem
- 报销单编号是序列自增的
- 报销单和考勤类一样有一个empid属性, 我们除了给出empid属性, 还要给出一个emp报销人属性, 因为添加的时候可能只要empid就够了, 但是查询的时候有个emp会更加方便
- 属性nextAuditorId下一个审核人的编号, 也是同样的原理, 我们同时补充上一个属性Employee类型的nextAuditor, 方便存放信息用于查询

### 报销管理-添加报销单-视图层
> 总结上面两个实体类之间的关系:报销单Expense和报销单明细ExpenseItem是一对多的关系  
> 在数据库中表示一对多的关系我们会给ExpenseItem表增加一个报销单expid的字段, 具体到Java类中我们会给ExpenseItem增加一个Expense的属性, 
同时也会给Expense增加一个集合属性, 用于存放ExpenseItem

1. 创建mvc的三层框架结构, dao层和数据库表一一对应, service层则不需要, 按照实际开发的需求创建
2. 复制得到expenseAdd.jsp
3. 报销人, 报销总额, 报销时间, 上级领导都是不用写的, 并且设置为只读, 注意:添加报销明细的代码中, 报销类型的type标签没有给出value值, 手动加上


### 报销管理-添加报销单-控制层
1. servlet中调用业务层完成添加报销单操作的返回值不再用一个int类型的数接收, 因为添加一个报销单还要添加一些明细, int数指向不明, 新的策略是使用异常捕获, 对业务层的操作进行try-catch
- 如果成功了跳转到myExpense.jsp, 出现异常则跳转回expenseAdd.jsp
2. 接收表单数据, 由于各个明细的属性名称是一样的, 使用getParameterValues()函数进行接收(type, amount, itemDesc), 同时还要给expenseItem添加一个对应这三个参数的构造方法
3. 把所有的明细都封装好, 添加到集合中, 然后封装好报销单对象, 把明细集合也添加到报销单对象中. (在循环封装明细的时候把总金额也计算好)
4. 记得在添加明细的代码中, 设置好name等属性值, 获取多个同名的属性使用getParamterValues();
> 主要学习如何获得多个名称相同的属性getParameterValues(""); 并把他们封装起来

### 报销管理-添加报销单-业务层
> 引入问题:业务层基本的流程很简单, 先把报销单添加到数据库中, 然后把报销单所属的明细添加到明细表中, 但是问题是:明细中有一项属性expid(报销单的编号), 这个编号是自增的, 我们如何获取到这个编号呢?

可以采取以下思路 : 
- 先查询数据库, 获得报销单编号expid下一个自增的值
- 把获得的expid设置给expense, 再添加入数据库
- 同时让明细设置这个expid, 再添加多条明细信息

### 报销管理-添加报销单-Dao层代码
1. 给Expense表和ExpenseItem表各添加一个自增序列
> 由于mysql没有自增序列的功能, 我们要手动实现序列功能
[参考这篇博客实现](https://blog.csdn.net/czbqoo01/article/details/70148516)
```
需要创建两个序列exp_seq, item_seq
第一个序列exp_seq:
CREATE TABLE exp_seq (
	NAME VARCHAR(50) NOT NULL PRIMARY KEY,
	start_value INT NOT NULL,
	increment_value INT NOT NULL DEFAULT 1
); --创建表模拟序列

INSERT INTO exp_seq VALUES('expid',1,1);-- 设置序列的初始值和增长值
 
DELIMITER //
CREATE FUNCTION nextval(str VARCHAR(50)) RETURNS INTEGER
BEGIN
	DECLARE i INT;
	SET i=(SELECT start_value FROM exp_seq WHERE NAME=str);
	UPDATE exp_seq
		SET start_value=i+increment_value
	WHERE NAME=str;
RETURN i;
END;-- 创建一个获得序列下一个值得函数
//

SELECT nextval('expid') FROM DUAL;-- 调用函数获取序列的下一个值


第二个序列item_seq:
CREATE TABLE item_seq (
	NAME VARCHAR(50) NOT NULL PRIMARY KEY,
	start_value INT NOT NULL,
	increment_value INT NOT NULL DEFAULT 1
);

INSERT INTO item_seq VALUES('itemid',1,1);
 
DELIMITER //
CREATE FUNCTION nextval_item_seq(str VARCHAR(50)) RETURNS INTEGER
BEGIN
	DECLARE i INT;
	SET i=(SELECT start_value FROM item_seq WHERE NAME=str);
	UPDATE item_seq
		SET start_value=i+increment_value
	WHERE NAME=str;
RETURN i;
END;
//

SELECT nextval_item_seq('itemid') FROM DUAL;

```
2. 完成保存操作, 把报销单添加到数据库中
3. 完成明细的保存操作, 以上2和3步骤注意两个表的主键是自增的
4. 在老师的演示中, 没有把Util类的Date转化为sql.Date, 但是出错后并没有报出错误, 因为与数据库有关的代码中自己处理了异常, 没有上报. 但是又不能在dbutil中把异常抛出来(throw e--SQLException), 因为抛出来后所有涉及dbutil的方法都要抓捕异常了
> 解决方法1:抛出运行时异常给调用者  
`throw new RuntimeException(e.toString)`  
> 解决办法2:自己定义一个异常类继承RuntimeException, 并重写无参和有参构造方法, 这样不仅处理而且把异常抛出去了

> **更大的问题来了**:会出现报销单提交成功, 明细提交失败的现象, 这样只提交了部分数据, 数据不完整.  
原因:一个DML操作一个事务, 事务在Dao层, 是多个事务  
解决:将多个操作视为同一个事务,这时事务要从dao层提升到业务层

### 报销管理-使用ThreadLocal实现业务层事务
1. 在service层中, 在添加报销单主单和明细的前后加上事务开启和事务结束
- 老师从头开始写, 如果使用JdbcUtils的话, 已经封装好了,可以查看他的源代码, 下面描述老师写事务的过程
- 开启事务:使用DBUtil获得链接对象, 设置事务不再自动提交
```
//开启事务
Connection con = DBUtil.getConnection();
try{
    con.setAutoCommit(false);//设置事务不自动结束,事务并没有开始, 
    ......//当dao层和数据库交互时, 事务才开启
    
}catch(...){
    //回滚
}
```
> 上面的事务操作, 并不能保证dao中每次使用的连接都是同一个连接, 一个比较笨的方法是把con传递给每个dao的方法, 但是我们用Threadlocal实现

- 定义一个ThreadLocal变量,存放的是Connection, 可以保证在同一个线程中, 不同层次, 不同方法都使用ThreadLocal的Connection, 保证了是同一个Connection
- JavaEE中客户端的每一个求情都是一个线程
- 在itcast工具包中, TxQueryRunner和JdbcUtils已经完美地封装好了事务的操作  

### 报销管理-待审报销单
1. 查询者只能看到报销单的上级领导是自己的报销单(有点拗口).
在left.jsp中, 访问待审核报销单的时候先访问Servlet的toAudit方法
- 从session中h获取当前用户的编号
- 调用业务层, 查询到当前用户需要审核的报销单
- 跳转到指定页面进行显示
2. service层添加方法ffindByAuditorId
3. 写好dao层, 需要多表查询(把用户的真实姓名查出来)  
老师的思路是,查完后再把审核人audit的id封装起来放到expense中, 我觉得不需要, 查出来后只要封装成expense集合, 显示审核人的时候显示当前登陆的用户就行了  
但是, 使用`select * from expense where nextAuditor=?`报错了

### 报销管理-审核报销单-视图层
审核结果:
- 通过:进入下一个审核人, 或者财务
- 拒绝:审核不通过, 审核结束
- 打回:审核不通过, 但是报销人可以重新再次填写报销  
- 
审核通过规则:
- 金额<=2500元,直接上级审核即可
- 金额>2500元, 需要总裁审核
- 审核通过后都会到达财务, 财务只能通过, 并产生支出
1. toAudit.jsp, 给审核的按键带上expense的expid参数再跳到audit.jsp
2. 给audit.jsp引入jQuery, 为了使用ajax准备
3. 给audit.jsp中加一个表单项显示expid参数,并设置为只读. 这里要注意, 由于expid不是在servlet中通过request.serAttribute存放的, 而是在地址中附带的, 所以  
```
${expid}    //不能使用这个, 这个相当于request.getAttribute(...)
${param.expid}  //应该使用这个, 这个相当于request.getParameter(...)
```
4. 由于我们使用ajax更新数据, 所以表单项要去掉onsubmit项, 并把submit键改为button
5. 设置在页面加载完成后, 给button绑定单击事件
- 先获得表单项的值, 注意这里涉及到如何用jQuery获取多选框的值
```
var resultArr = $("input[name=result]");
var result;//获取单选框中选中的值
for(var i=0; i<result.length; i++){
    var flag = $(result[i]).prop("checked"); //1.4使用attr，1.6之后使用prop //result[i]是js对象, $(result[i])才是jQuery对象
    if(flag){
        //result = $(resultArr[i]).val(); //这是jQuery的写法
        result = resultArr[i].value;    //这是js的写法
        break;
    }
}
```
- 完成ajax代码, ajax中url访问的是servlet中的audit方法

### 报销管理-审核报销单-控制层代码和业务层思路
1. 在servlet中的audit方法中, 按如下的步骤进行:
- 获取审核表单的值
- 调用业务层完成审核操作
- 输出结果ajax
2. 具体步骤:先创建auditing实体类,  
老套路:由于auditing类中又expid和empid两项属性,为了获得员工类和报销单类的信息, 我们在添加两个属性emp和exp,  
注意:
- time属性需要精确到yyyyMMddhhmmss
- auditId设置为自增
- 审核人从session中获取
3. 对调用业务层的代码用进行try-catch, 成功则则行try块中的代码, 失败则执行catch块中的代码
4. 业务层的代码需要修改两张表:在auditing中添加一次审核, 然后修改报销单表中的信息, 为了保证这两步不出错, 我们要在业务层使用事务  
[image](36B36531E6E74C08883B30FEC8D78445)  
```
//开启事务
//审核通过吗?
if(//通过){
    if(//是财务吗){
        //是财务
        //添加指出记录
        
        //修改报销单状态
    }else{
        //金额大于2500吗?
        if(//金额大于2500){
            //当前审核人是总裁吗
            if(//是总裁){
                //添加审核记录
    
                //修改报销单状态    
            }else{
                //添加审核记录
    
                //修改报销单状态 
            }
            
        }else{//金额小于2500
            //添加审核记录
    
            //修改报销单状态

        }
    }
    
}else{//不通过,拒绝或者打回
    //添加审核记录
    
    //修改报销单状态
}

```
### 报销管理-审核报销-Dao层和业务层代码实现
1. 在expenseDaoImpl中添加修改报销单的方法,通过expid修改nextauditor, lastResult, status
2. 创建AuditingDao(接口-实现类), 添加方法save添加审核记录, 注意在添加Auditing的时候, auditid是通过自增序列获取的
- 在把时间写入数据库表的时候,由于这次需要年月日时分秒, 我们使用时间戳`java.sql.Timestamp(auditing.getAuditTime().getTime());`
3. 我们先写最外面一层if代码,添加审核记录和修改报销单状态分别调用上面的方法
- 修改报销单状态, 我们需要创建一个报销单对象, 把需要修改的参数传进去
```
//修改报销单状态
//不通过被拒绝或打回
Expense exp = new Expense();
expense.setExpId(auditing.getExpId)
if("打回".equals(auditing.getResult())){
    exp.setStatus("4");
}else{
    exp.setStatus("3");
}
exp.setLastResult(auditing.getResult());
//由于被打回, 下一级处理人写null, 没有下个审核人
//最后调用dao层的update方法
```

```
//审核通过, 金额小于2500, 这时:下个处理人是财务,状态:通过
Expense exp = new Expense();
expense.setExpId(auditing.getExpId)
exp.setStatus("2");
exp.setLastResult(auditing.getResult());
exp.setNextAuditor("财务人员的id");
expDao.update(exp);
```

```
金额大于2500, 审核人是总裁, 代码和上面的一样
```

```
金额大于2500, 审核人不是总裁
修改审核状态为1, 审核中
把下一级审核人的id写为总裁的id(降低了难度)
```

步骤继续:
4. 最外面的if语句判断的是是否通过, 我们获得auditing的结果就知道有没有通过了
```
//判断是否通过
if("通过".equals(result){
    
}

//判断是否是财务
if(auditing.getEmp().getPos().getPosid() == 3){
    
}

//判断报销金额是否大于2500, 注意目前还没有把exp的详细信息放入到auditing中
if(auditing.getExp().getTotalAmount() > 2500){
    
}

//当前审核人是总裁小猪吗
if("xiaozhu".equal(auditing.getEmp().getEmpid())){
    
}
```
5. servlet中,我们把最终成功或者失败的信息响应给ajax
6. ajax根据成功/失败信息做出响应操作
- 失败就好说, 直接alert出失败
- 成功的话, 我们的思路是关闭当前子窗口, 刷新父窗口(审核状态)
```
if(data=='success'){
    //刷新父窗口
    //window.location.reload();刷新的是当前窗口的地址栏
    window.opener.location.reload();//刷新的是父窗口的地址栏
    //关闭当前窗口
    window.close();
}
```
7. 错误肯定是很多的了, 慢慢调试:
- 审核窗口按提交没有反应, 因为老师使用的jQuery是1.4版本, 不支持拿到元素后用$(...).prop, 用.prop获得属性要1.6版本以后才可以, 1.4只能用.attr代替
- 没有拿到Exp的详细信息, 所以判断报销单金额的时候出现空指针异常-----解决:老师直接调用dao层通过expid查找exp

### 遇到的问题
> Cannot set (属性名称) : incompatible types  
查询数据库时出现的异常, 原因:我把查询后的结果用BeanHandler等工具类装起来, 使用这些工具必须要保证数据库表的字段和javabean的属性名称一致才行, 修改即可.

8. 财务添加支出记录留到写支出功能的时候再完善, 这时候可以把业务流程中重复的代码提取出来, 但是会降低一点可读性
9. 在工具包下面创建一个constants类, 常量类:里面存放报销单的状态, 总裁, 财务经理等的id号
```
public static final String EXPENSE_STATUS_NEW = "0";//新创建
......
```
10. 最后学习如何使用powerDesigner绘制业务流程图
File->新建一个模型->model types->business process Model业务流程
- 实心点是开始, 有个圆包着的是结束, 可以用鼠标左键选中, 然后居中对齐, 要在线上面添加文字, 可以到右边的工具栏选择T文字框, 并进行添加文字